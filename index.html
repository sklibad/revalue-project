<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin=""/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="src/leaflet.legend.css" />
    <link rel="stylesheet" href="map1.css?v=1.1" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="Control.FullScreen.js"></script>
    <script src="map1.js?v=<?php echo time(); ?>" type="text/javascript"></script>
    <script type="text/javascript" src="src/leaflet.legend.js"></script>
    <title>Map1</title>
</head>
<body>
    <div id="map"></div>
    <div id="popup" class="popup">
        <label for="opacitySlider">Opacity:</label>
        <input type="range" id="opacitySlider" min="0" max="1" step="0.01">
        <label for="colorPicker" id="colorPickerLabel">Color:</label>
        <input type="color" id="colorPicker">
    </div>
    <script type="text/javascript">
        var map = L.map('map', {
            fullscreenControl: true,
            fullscreenControlOptions: {
                title: "Turn on fullscreen",
                titleCancel: "Exit fullscreen mode"
            }
        }).setView([62.62357822995269, 6.568337702605886], 9);

        var OSmap = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a>',
            opacity: 0.5
        }).addTo(map);

        var Imagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.arcgis.com/home/item.html?id=10df2279f9684e4a9f6a7f08febac2a9" target="_blank">ESRI</a> | <a href="https://www.linkedin.com/in/david-skliba/?locale=en_US" target="_blank">David Šklíba</a>',
            opacity: 1
        });

        var TopoMap = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href = "https://opentopomap.org/credits" target = "_blank">OpenTopoMap</a> | <a href="https://www.linkedin.com/in/david-skliba/?locale=en_US" target="_blank">David Šklíba</a>',
            opacity: 0.5
        });

        var baseLayers = {
            "OS Map": OSmap,
            "Imagery": Imagery,
            "TopoMap": TopoMap
        };

        let selectedColor = '#450e1c'; // Default color

        var overlayLayers = {
            "Alesund": L.geoJSON(alesund, { style: getGeoJsonStyle(0) }),
            "Cascais": L.geoJSON(cascais, { style: getGeoJsonStyle(0) }),
            "Bruges": L.geoJSON(bruges, { style: getGeoJsonStyle(0) }),
            "Burgas": L.geoJSON(burgas, { style: getGeoJsonStyle(0) }),
            "Constanta": L.geoJSON(constanta, { style: getGeoJsonStyle(0) }),
            "Izmir": L.geoJSON(izmir, { style: getGeoJsonStyle(0) }),
            "Pisek": L.geoJSON(pisek, { style: getGeoJsonStyle(0) }),
            "Rijeka": L.geoJSON(rijeka, { style: getGeoJsonStyle(0) }),
            "Rimini": L.geoJSON(rimini, { style: getGeoJsonStyle(0) })
        };

        overlayLayers[Object.keys(overlayLayers)[0]].addTo(map)

        function getGeoJsonStyle(fillOpacity = 1) {
            return {
                fillColor: lightenColor(selectedColor, 0.5),
                fillOpacity: fillOpacity,
                color: selectedColor,
                weight: 2
            };
        }

        var layerViewSettings = {
            "Alesund": { center: [62.62357822995269, 6.568337702605886], zoom: 9 },
            "Cascais": { center: [38.7246415419252, -9.398661627395064], zoom: 12 },
            "Bruges": { center: [51.26277668564624, 3.2157520267962854], zoom: 11 },
            "Burgas": { center: [42.52365465796975, 27.412133356605594], zoom: 10 },
            "Constanta": { center: [44.18397145865716, 28.595090491839358], zoom: 11 },
            "Izmir": { center: [38.4274666702251, 27.15412241220643], zoom: 11 },
            "Pisek": { center: [49.28765927177321, 14.167823590584321], zoom: 12 },
            "Rijeka": { center: [45.338554885503896, 14.424501967276987], zoom: 12 },
            "Rimini": { center: [44.05320342546707, 12.56987993983287], zoom: 13 }
        };

        let activeLayers = {};
        let selectedLayer = null;

        async function fetchExtents(path) {
            try {
                const response = await fetch(path);
                const extents = await response.json();
                return extents;
            } catch (error) {
                console.error('Error fetching extents:', error);
                return {};
            }
        }

        async function updateMapWithPng(path, subcategory, pngFileName) {
            const extents = await fetchExtents(`${path}/metadata.json`);
            const extent = extents[pngFileName].extent;

            if (extent) {
                const layer = L.imageOverlay(`${path}/${pngFileName}.png`, extent).addTo(map);

                layer.getElement().style.imageRendering = 'pixelated';

                const layerName = `${subcategory} - ${pngFileName}`;

                // Create a new object with the new layer at the first position
                const newActiveLayers = { [layerName]: layer, ...activeLayers };
                activeLayers = newActiveLayers;

                updateActiveLayersPanel();
            }
        }

        // Utility function to lighten a color
        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent * 100);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;

            return "#" + (
                0x1000000 +
                (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)
            ).toString(16).slice(1).toUpperCase();
        }

        // Function to show popup for opacity control and legend display
        async function showPopup(event, layerName) {
            const popup = document.getElementById('popup');
            popup.style.display = 'block';
            popup.style.top = `${event.clientY + 5}px`;
            popup.style.left = `${event.clientX - popup.offsetWidth}px`;

            const slider = document.getElementById('opacitySlider');
            const colorPickerLabel = document.getElementById('colorPickerLabel');
            const colorPicker = document.getElementById('colorPicker');

            const layer = activeLayers[layerName];

            // Set initial slider and color picker values based on the layer's current style
            if (layer instanceof L.GeoJSON) {
                colorPickerLabel.style.display = 'inline';
                colorPicker.style.display = 'inline';
                const firstFeature = layer.getLayers()[0];
                const currentColor = firstFeature.options.color || '#000000';
                colorPicker.value = currentColor;
            } else {
                colorPickerLabel.style.display = 'none';
                colorPicker.style.display = 'none';
            }

            slider.oninput = function () {
                const value = this.value;

                if (layer instanceof L.GeoJSON) {
                    layer.eachLayer(function (featureLayer) {
                        if (featureLayer.setStyle) {
                            featureLayer.setStyle({ opacity: value, fillOpacity: value });
                        }
                    });
                } else if (layer instanceof L.ImageOverlay) {
                    layer.setOpacity(value);
                }
            };

            if (layer instanceof L.GeoJSON) {
                slider.value = layer.options.style ? layer.options.style.opacity || 1 : 1;
            } else if (layer instanceof L.ImageOverlay) {
                slider.value = layer.options.opacity || 1;

                // Clear the existing legend content
                const legendContainer = document.getElementById('legend-container');
                if (legendContainer) {
                    legendContainer.remove();
                }

                // Assuming the URL is stored in layer.options.url
                const filePath = layer._url;
                const fileName = layerName.split(" - ")[1]
                const subcategoryName = layerName.split(" - ")[0]
                const jsonFilePath = filePath.replace(`${fileName}.png`, 'metadata.json?v=${timestamp}');
                const imageJSON = await fetchExtents(jsonFilePath);
                const legendData = imageJSON[fileName];
                const legendHtml = createColorBarLegend(legendData, subcategoryName);
                
                // Create a container for the legend and append it to the popup
                const legendDiv = document.createElement('div');
                legendDiv.id = 'legend-container'; // Add an ID to identify it
                legendDiv.innerHTML = legendHtml;
                popup.appendChild(legendDiv);
            }

            colorPicker.oninput = function () {
                selectedColor = this.value;
                const fillColor = lightenColor(selectedColor, 0.5);

                // Update the styles of the currently active layer
                if (layer instanceof L.GeoJSON) {
                    layer.eachLayer(function (featureLayer) {
                        if (featureLayer.setStyle) {
                            featureLayer.setStyle({ color: selectedColor, fillColor: fillColor });
                        }
                    });
                }

                updateDrawingOptions();
            };
        }

        // Function to hide the popup
        function hidePopup() {
            const popup = document.getElementById('popup');
            popup.style.display = 'none';
        }

        async function fetchFolders(path) {
            try {
                const response = await fetch(path); // Fetch based on the specific path
                const folders = await parseResponseToFolders(response);
                return folders;
            } catch (error) {
                console.error('Error fetching folders:', error);
                return [];
            }
        }

        async function fetchFiles(path) {
            try {
                const response = await fetch(path); // Fetch based on the specific path
                const files = await parseResponseToFiles(response);
                return files;
            } catch (error) {
                console.error('Error fetching files:', error);
                return [];
            }
        }

        // Helper functions to parse the response correctly
        async function parseResponseToFolders(response) {
            const responseText = await response.text();
            const contentType = response.headers.get('content-type');
            if (contentType.includes('application/json')) {
                return JSON.parse(responseText);
            } else if (contentType.includes('text/html')) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(responseText, 'text/html');
                const links = Array.from(doc.querySelectorAll('a'));
                return links.map(link => link.textContent).filter(name => name.endsWith('/')).map(name => name.slice(0, -1));
            }
            return [];
        }

        async function parseResponseToFiles(response) {
            const responseText = await response.text();
            const contentType = response.headers.get('content-type');
            if (contentType.includes('application/json')) {
                return JSON.parse(responseText);
            } else if (contentType.includes('text/html')) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(responseText, 'text/html');
                const links = Array.from(doc.querySelectorAll('a'));
                return links.map(link => link.textContent);
            }
            return [];
        }

        function updateDropdownOptions(dropdown, options, title) {
            dropdown.innerHTML = `<option value="">${title}</option>`;
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option.endsWith('.png') ? option.slice(0, -4) : option;
                dropdown.appendChild(opt);
            });
        }

        async function updateFolderDropdown(layerName) {
            const folders = await fetchFolders(layerName); // Fetch folders for the specific layer
            const dropdown = document.getElementById('folderDropdown');
            updateDropdownOptions(dropdown, folders, 'Select a category');
        }

        async function updateFileOrSubcategoryDropdown(path) {
            const files = await fetchFiles(path);
            const pngFiles = files.filter(file => file.endsWith('.png'));
            const subfolders = files.filter(file => file.endsWith('/')).map(name => name.slice(0, -1));

            const container = document.getElementById('additionalDropdownContainer');
            container.innerHTML = '';

            const label = document.createElement('div');
            label.textContent = pngFiles.length > 0 ? 'Data' : 'Subcategory';
            label.style.marginTop = '10px';
            container.appendChild(label);

            const dropdown = document.createElement('select');
            dropdown.id = 'additionalDropdown';

            if (pngFiles.length > 0) {
                updateDropdownOptions(dropdown, pngFiles, 'Select an option');
            } else {
                updateDropdownOptions(dropdown, subfolders, 'Select a subcategory');
            }

            container.appendChild(dropdown);

            if (subfolders.length > 0) {
                dropdown.addEventListener('change', function () {
                    const selectedSubfolder = this.value;
                    if (selectedSubfolder) {
                        updatePngFilesDropdown(`${path}/${selectedSubfolder}`);
                    }
                });
            }

            updateActiveLayersPanel();
        }

        async function updatePngFilesDropdown(path) {
            const files = await fetchFiles(path);
            const pngFiles = files.filter(file => file.endsWith('.png'));

            const container = document.getElementById('pngFilesDropdownContainer');
            container.innerHTML = ''; // Clear previous content

            const label = document.createElement('div');
            label.textContent = 'Data';
            container.appendChild(label);

            const dropdown = document.createElement('select');
            dropdown.id = 'pngFilesDropdown';
            updateDropdownOptions(dropdown, pngFiles.map(file => file.slice(0, -4)), 'Select data');

            dropdown.addEventListener('change', function () {
                const selectedPngFile = this.value;
                if (selectedPngFile) {
                    const subcategory = document.getElementById('additionalDropdown').value;
                    updateMapWithPng(path, subcategory, selectedPngFile);
                }
            });

            container.appendChild(dropdown);

            updateActiveLayersPanel();
        }

        // Utility function to create the colorbar legend HTML
        function createColorBarLegend(legendData, subcategoryName) {
            const colorStops = legendData.colorStops;
            const minValue = legendData.minValue;
            const maxValue = legendData.maxValue;
            const units = legendData.units.replace(/\^(\w)/g, '<sup>$1</sup>');

            let legendHtml = '<div class="colorbar-legend">';
            legendHtml += `<div class="colorbar-title">${subcategoryName} (${units})</div>`;
            legendHtml += '<div class="colorbar-gradient" style="background: linear-gradient(to right, ';

            colorStops.forEach((stop, index) => {
                legendHtml += `${stop.color}`;
                if (index < colorStops.length - 1) {
                    legendHtml += ', ';
                }
            });

            legendHtml += ');">';

            // Adding marks (ticks)
            colorStops.forEach((stop) => {
                const positionPercent = ((stop.value - minValue) / (maxValue - minValue)) * 100;
                legendHtml += `<div class="colorbar-tick" style="left: ${positionPercent}%;"></div>`;
            });

            legendHtml += '</div>'; // Close .colorbar-gradient

            // Adding value labels below the color bar
            legendHtml += '<div class="colorbar-labels">';
            colorStops.forEach((stop) => {
                const positionPercent = ((stop.value - minValue) / (maxValue - minValue)) * 100;
                legendHtml += `<div class="colorbar-label" style="left: ${positionPercent}%; text-align: center;">${stop.value}</div>`;
            });
            legendHtml += '</div>'; // Close .colorbar-labels

            legendHtml += '</div>'; // Close .colorbar-legend

            return legendHtml;
        }

        function clearDropdownsExceptFirst(container) {
            // Get the first dropdown
            let firstDropdown = container.querySelector('select');
            
            // If the first dropdown doesn't exist, create it
            if (!firstDropdown) {
                firstDropdown = document.createElement('select');
                firstDropdown.style.width = '100%'; // Ensure it fits the container width
                firstDropdown.style.overflow = 'hidden'; // Hide overflow
                firstDropdown.style.textOverflow = 'ellipsis'; // Add ellipsis for overflowed text
                firstDropdown.style.whiteSpace = 'nowrap'; // Prevent text from wrapping
                container.appendChild(firstDropdown);
            }

            // Reset the first dropdown to its default state
            firstDropdown.innerHTML = '<option value="">Select weather data</option>';

            // Remove all other dropdowns or elements below the first dropdown
            while (container.children.length > 1) {
                container.removeChild(container.lastChild);
            }
        }


        function refreshDropdowns(selectedLayer) {
            const container = document.querySelector('.dropdown-container');

            // Ensure the first dropdown is created and clear all other dropdowns
            clearDropdownsExceptFirst(container); // Clear everything except the first dropdown

            // Re-select or create the first dropdown
            let firstDropdown = container.querySelector('select');
            if (!firstDropdown) {
                firstDropdown = document.createElement('select');
                firstDropdown.style.width = '100%'; // Ensure it fits the container width
                firstDropdown.style.overflow = 'hidden'; // Hide overflow
                firstDropdown.style.textOverflow = 'ellipsis'; // Add ellipsis for overflowed text
                firstDropdown.style.whiteSpace = 'nowrap'; // Prevent text from wrapping
                firstDropdown.id = 'dynamicDropdown';
                container.appendChild(firstDropdown);
            }

            // Fetch data and populate the first dropdown
            fetchJsonData('merged.json').then(data => {
                if (data && data[selectedLayer]) {
                    populateDropdown(firstDropdown, data[selectedLayer], "Select weather data");

                    // Add change event to create a new dropdown when an option is selected
                    firstDropdown.onchange = function () {
                        const selectedOption = this.value;
                        createNewDropdown(container, data[selectedLayer][selectedOption]);
                    };
                } else {
                    firstDropdown.innerHTML = '<option value="">No data available</option>';
                }
            });
        }




        var overlayControl = L.control({ position: 'topright' });

        overlayControl.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend section-container');
            div.style.backgroundColor = 'white';
            div.style.padding = '10px';
            div.style.border = '2px solid #ccc';
            div.style.borderRadius = '5px';
            div.style.position = 'relative'; // To allow absolute positioning of logos

            // Add logos to the top-right
            var logo1 = L.DomUtil.create('img', 'logo', div);
            logo1.src = 'ikony/revalue.jpeg'; // Replace with your logo1 path
            logo1.style.position = 'absolute';
            logo1.style.top = '0';
            logo1.style.right = '40px';
            logo1.style.width = '80px'; // Adjust size as needed
            logo1.style.height = 'auto'; // Maintain aspect ratio

            var logo2 = L.DomUtil.create('img', 'logo', div);
            logo2.src = 'ikony/ecoten.svg'; // Replace with your logo2 path
            logo2.style.position = 'absolute';
            logo2.style.top = '80px'; // Positioned below the first logo
            logo2.style.right = '10px';
            logo2.style.width = '120px'; // Adjust size as needed
            logo2.style.height = 'auto'; // Maintain aspect ratio

            for (var i = 0; i < Object.keys(overlayLayers).length; i++) {
                var layerName = Object.keys(overlayLayers)[i];
                var checkedAttribute = i === 0 ? 'checked' : '';

                div.innerHTML +=
                    '<input type="radio" name="layer" value="' + layerName + '" id="' + layerName + '" ' + checkedAttribute +
                    ' title="Switch to ' + layerName + '">' +
                    '<label for="' + layerName + '" title="Switch to ' + layerName + '">' + layerName + '</label><br>';
            }

            div.innerHTML += '<br><label for="folderDropdown">Category:</label><br>';
            var select = L.DomUtil.create('select', '', div);
            select.id = 'folderDropdown';
            select.innerHTML = '<option value="">Select a category</option>';

            select.addEventListener('change', function () {
                const selectedOption = this.value;
                const selectedLayer = document.querySelector('input[name="layer"]:checked').value;
                const path = `${selectedLayer}/${selectedOption}`;
                updateFileOrSubcategoryDropdown(path);
            });

            div.addEventListener('change', function (e) {
                if (e.target.name === 'layer') {
                    var selectedLayer = e.target.value;

                    for (var layerName in overlayLayers) {
                        if (overlayLayers.hasOwnProperty(layerName) && layerName !== selectedLayer) {
                            map.removeLayer(overlayLayers[layerName]);
                        }
                    }
                    overlayLayers[selectedLayer].addTo(map);

                    if (layerViewSettings[selectedLayer]) {
                        map.setView(layerViewSettings[selectedLayer].center, layerViewSettings[selectedLayer].zoom);
                    }

                    // Update the folder dropdown for the selected city
                    //updateFolderDropdown(selectedLayer);

                    // Clear and refresh the dropdowns for the selected layer
                    refreshDropdowns(selectedLayer);
                }
            });

            // Add the file upload button above the Active Layers section
            var fileUploadContainer = L.DomUtil.create('div', '', div);
            fileUploadContainer.style.marginTop = '10px';

            var fileUploadButton = L.DomUtil.create('input', '', fileUploadContainer);
            fileUploadButton.type = 'file';
            fileUploadButton.accept = '.geojson';
            fileUploadButton.style.width = '100%';

            fileUploadButton.addEventListener('change', function (event) {
                var file = event.target.files[0];
                if (file) {
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        var geojson = JSON.parse(e.target.result);
                        var layer = L.geoJSON(geojson, { style: 
                            {fillColor: lightenColor("#33302a", 0.5),
                                fillOpacity: 1,
                                color: "#33302a",
                                weight: 2
                            } 
                        }).addTo(map);
                        const bounds = layer.getBounds();
                        map.fitBounds(bounds); 
                        const layerName = `${file.name.slice(0, -8)}`;

                        // Create a new object with the new layer at the first position
                        const newActiveLayers = { [layerName]: layer, ...activeLayers };
                        activeLayers = newActiveLayers;

                        updateActiveLayersPanel();
                    };
                    reader.readAsText(file);
                }
            });


            var additionalDropdownContainer = L.DomUtil.create('div', '', div);
            additionalDropdownContainer.id = 'additionalDropdownContainer';
            additionalDropdownContainer.style.marginTop = '10px';

            var pngFilesDropdownContainer = L.DomUtil.create('div', '', div);
            pngFilesDropdownContainer.id = 'pngFilesDropdownContainer';
            pngFilesDropdownContainer.style.marginTop = '10px';

            var activeLayersContainer = L.DomUtil.create('div', '', div);
            activeLayersContainer.id = 'activeLayersContainer';
            activeLayersContainer.style.marginTop = '10px';

            var activeLayersHeader = L.DomUtil.create('h4', '', activeLayersContainer);
            activeLayersHeader.textContent = 'Active Layers';

            var activeLayersList = L.DomUtil.create('div', '', activeLayersContainer);
            activeLayersList.id = 'activeLayersList';

            var moveButtonsContainer = L.DomUtil.create('div', '', activeLayersContainer);
            moveButtonsContainer.style.marginTop = '10px';

            var moveUpButton = L.DomUtil.create('button', 'move-button', moveButtonsContainer);
            moveUpButton.innerHTML = '<i class="fa fa-arrow-up"></i>';
            moveUpButton.onclick = function () {
                moveLayerUp();
            };

            var moveDownButton = L.DomUtil.create('button', 'move-button', moveButtonsContainer);
            moveDownButton.innerHTML = '<i class="fa fa-arrow-down"></i>';
            moveDownButton.onclick = function () {
                moveLayerDown();
            };

            div.appendChild(additionalDropdownContainer);
            div.appendChild(pngFilesDropdownContainer);
            div.appendChild(activeLayersContainer);
            div.appendChild(fileUploadContainer);

            return div;
        };

        // Function to create a new dropdown based on the selected key
// Create a new control for the dropdown menus
var dropdownControl = L.control({ position: 'bottomleft' });

dropdownControl.onAdd = function (map) {
    var div = L.DomUtil.create('div', 'info dropdown-container');
    div.style.backgroundColor = 'white';
    div.style.padding = '10px';
    div.style.border = '2px solid #ccc';
    div.style.borderRadius = '5px';
    div.style.marginTop = '10px'; // Add margin to separate it from the overlayControl section
    div.style.width = '200px';

    // Create a headline for the section
    var headline = document.createElement('h3');
    headline.innerHTML = 'Climate data in graphs'; // Set the headline text
    headline.style.marginBottom = '10px'; // Add some spacing below the headline
    div.appendChild(headline);

    // Create the first dropdown menu
    var select = L.DomUtil.create('select', '', div);
    select.id = 'dynamicDropdown';
    select.innerHTML = '<option value="">Loading...</option>'; // Default message
    select.style.width = '100%'; // Ensure it fits the container width
    select.style.overflow = 'hidden'; // Hide overflow
    select.style.textOverflow = 'ellipsis'; // Add ellipsis for overflowed text
    select.style.whiteSpace = 'nowrap'; // Prevent text from wrapping

    // Function to handle radio button change
    function handleRadioChange() {
        // Clear existing dropdowns except the first one
        clearDropdowns(div);

        // Fetch JSON data and populate the first dropdown based on the selected radio button
        fetchJsonData('merged.json').then(data => {
            const selectedRadioValue = document.querySelector('input[name="layer"]:checked').value;

            if (data && data[selectedRadioValue]) {
                populateDropdown(select, data[selectedRadioValue], "Select weather data");

                // Add change event to create a new dropdown when an option is selected
                select.onchange = function () {
                    const selectedOption = this.value;
                    // Clear any existing dropdowns below this one before creating a new one
                    clearDropdownsBelow(select);
                    createNewDropdown(div, data[selectedRadioValue][selectedOption]);
                };
            } else {
                select.innerHTML = '<option value="">No data available</option>';
            }
        });
    }

    // Add event listener for radio button changes
    document.querySelectorAll('input[name="layer"]').forEach(radio => {
        radio.addEventListener('change', handleRadioChange);
    });

    // Initial load based on the initially selected radio button
    handleRadioChange();

    return div;
};

// Modify the createNewDropdown function to apply custom placeholders for the first and second dropdowns
function createNewDropdown(container, data, dropdownCount = 1) {
    if (!data || typeof data !== 'object') return;

    // Check if a "Scenario" dropdown already exists and return if it does
    if (dropdownCount === 1) {
        const existingScenarioDropdown = container.querySelector('select[placeholder="Scenario"]');
        if (existingScenarioDropdown) {
            clearDropdownsBelow(container.querySelector('select'));
        }
    }
    
    // Create a new dropdown menu below the current one
    var newDropdown = document.createElement('select');
    newDropdown.className = 'dropdown-menu'; // Add class for styling
    newDropdown.style.width = '100%'; // Ensure it fits the container width
    newDropdown.style.overflow = 'hidden'; // Hide overflow
    newDropdown.style.textOverflow = 'ellipsis'; // Add ellipsis for overflowed text
    newDropdown.style.whiteSpace = 'nowrap'; // Prevent text from wrapping

    // Set custom placeholder based on dropdown count
    let placeholder;
    if (dropdownCount === 1) {
        placeholder = "Scenario";  // Custom placeholder for the first dropdown
    } else if (dropdownCount === 2) {
        placeholder = "Temporal resolution";  // Custom placeholder for the second dropdown
    } else {
        placeholder = "Select an option"; // Default placeholder for other dropdowns
    }

    newDropdown.setAttribute('placeholder', placeholder); // Set the placeholder as an attribute
    populateDropdown(newDropdown, data, placeholder);

    // Insert the dropdown without unnecessary spacing
    container.appendChild(newDropdown);

    // Add change event to the new dropdown to create another one if there are more nested options
    newDropdown.onchange = function () {
        // Clear all dropdowns below this one
        clearDropdownsBelow(newDropdown);
        
        if (this.value && data[this.value]) {
            const nextData = data[this.value];
            // If it's the second dropdown, add the "From" and "To" dropdowns
            if (dropdownCount === 2) {
                addFromToDropdowns(container, nextData);
            } else {
                // Create a new dropdown if a valid option is selected
                createNewDropdown(container, nextData, dropdownCount + 1);
            }
        }
    };
}

// Function to handle radio button change
function handleRadioChange() {
    // Clear existing dropdowns except the first one and the button
    clearDropdowns(div);

    // Fetch JSON data and populate the first dropdown based on the selected radio button
    fetchJsonData('merged.json').then(data => {
        const selectedRadioValue = document.querySelector('input[name="layer"]:checked').value;

        if (data && data[selectedRadioValue]) {
            populateDropdown(select, data[selectedRadioValue], "Scenario"); // Custom placeholder for the first dropdown

            // Add change event to create a new dropdown when an option is selected
            select.onchange = function () {
                const selectedOption = this.value;
                // Clear any existing dropdowns below this one before creating a new one
                clearDropdownsBelow(select);
                createNewDropdown(div, data[selectedRadioValue][selectedOption]);
            };
        } else {
            select.innerHTML = '<option value="">No data available</option>';
        }
    });
}

// Function to clear existing dropdowns except the first one
function clearDropdowns(container) {
    // Remove all children except the first three (headline, label, and first dropdown)
    while (container.children.length > 3) {
        container.removeChild(container.lastChild);
    }

    // Clear the options of the first dropdown
    const firstDropdown = container.querySelector('select');
    if (firstDropdown) {
        firstDropdown.innerHTML = '<option value="">Select weather data</option>';
    }
}

// Function to clear all dropdowns below the given dropdown
function clearDropdownsBelow(dropdown) {
    const container = dropdown.parentElement;
    // Remove all elements below the dropdown, including the submit button
    while (dropdown.nextSibling) {
        container.removeChild(dropdown.nextSibling);
    }
}

// Function to add "From" and "To" dropdowns
function addFromToDropdowns(container, data) {
    // Add a container to hold both "From" and "To" dropdowns side by side
    var fromToContainer = document.createElement('div');
    fromToContainer.style.display = 'flex';
    fromToContainer.style.gap = '10px'; // Adjust gap between "From" and "To"
    container.appendChild(fromToContainer);

    var fromDropdown = document.createElement('select');
    fromDropdown.className = 'dropdown-menu';
    populateDropdown(fromDropdown, data, "From");
    fromToContainer.appendChild(fromDropdown);

    var toDropdown = document.createElement('select');
    toDropdown.className = 'dropdown-menu';
    populateDropdown(toDropdown, data, "To");
    fromToContainer.appendChild(toDropdown);

    // Add event listeners to "From" and "To" dropdowns
    fromDropdown.addEventListener('change', checkAndAddSubmitButton);
    toDropdown.addEventListener('change', checkAndAddSubmitButton);

    // Function to check if both dropdowns have a value selected, then add the submit button
    function checkAndAddSubmitButton() {
        if (fromDropdown.value && toDropdown.value) {
            addSubmitButton(container, data, fromDropdown.value, toDropdown.value);
        }
    }
}

// Function to add a submit button
function addSubmitButton(container, data, fromKey, toKey) {
    // Remove any existing button first
    const existingButton = container.querySelector('.submit-button');
    if (existingButton) {
        container.removeChild(existingButton);
    }

    var button = document.createElement('button');
    button.className = 'submit-button';
    button.innerHTML = 'Create graph';
    button.style.marginTop = '10px';
    container.appendChild(button);

    // Add event listener to the button to display the graph in a popup
    button.addEventListener('click', function () {
        showGraphPopup(data, fromKey, toKey);
    });
}

// Function to show graphs in a popup with a grid layout
function showGraphPopup(data, fromKey, toKey) {
    // Get the selected option from the default dropdown
    const defaultDropdown = document.getElementById('dynamicDropdown');
    const selectedWeatherData = defaultDropdown ? defaultDropdown.options[defaultDropdown.selectedIndex].text : '';

    // Get the selected option from the "Scenario" dropdown
    const scenarioDropdown = document.querySelector('.dropdown-menu');
    const selectedScenario = scenarioDropdown ? scenarioDropdown.options[scenarioDropdown.selectedIndex].text : '';

    // Combine the names from "Select weather data" and "Scenario"
    const graphTitleText = `${selectedWeatherData} (${selectedScenario})`;

    // Create a popup div if it doesn't exist
    let popup = document.getElementById('graphPopup');
    if (!popup) {
        popup = document.createElement('div');
        popup.id = 'graphPopup';
        popup.style.position = 'fixed';
        popup.style.top = '50%';
        popup.style.left = '50%';
        popup.style.transform = 'translate(-53%, -50%)';
        popup.style.backgroundColor = 'white';
        popup.style.padding = '5px 20px 5px 20px';
        popup.style.border = '2px solid #ccc';
        popup.style.borderRadius = '10px';
        popup.style.zIndex = '1000';
        popup.style.display = 'grid';
        popup.style.gridTemplateColumns = '1fr 1fr'; // Two columns
        popup.style.gridTemplateRows = '1fr 1fr';    // Two rows
        popup.style.gridGap = '10px';                // Gap between graphs
        popup.style.width = '52%';                   // Set the width of the popup
        popup.style.height = '85%';                  // Set the height of the popup to 85%
        document.body.appendChild(popup);
    }

    // Ensure a maximum of 4 graphs
    if (popup.querySelectorAll('canvas').length >= 4) { // Check if there are already 4 graphs
        return; // Exit the function without creating a new graph
    }

    // Calculate the available height for each graph container (considering 4 graphs)
    const availableHeight = popup.clientHeight;
    const graphContainerHeight = (availableHeight / 2) - 40; // 40px for padding, title, and button

    // Create a container for each graph and its close button
    var graphContainer = document.createElement('div');
    graphContainer.style.position = 'relative';
    graphContainer.style.width = '100%';  // Full width of the grid cell
    graphContainer.style.height = `${graphContainerHeight}px`; // Set height based on available space
    popup.appendChild(graphContainer);

    // Create a title for the graph
    var graphTitle = document.createElement('h4');
    graphTitle.innerHTML = graphTitleText;
    graphTitle.style.textAlign = 'center';
    graphTitle.style.marginBottom = '5px';
    graphContainer.appendChild(graphTitle);

    // Create a canvas for Chart.js
    var canvas = document.createElement('canvas');
    canvas.width = graphContainer.clientWidth;  // Set width of the chart to match container
    canvas.height = graphContainerHeight - 50; // Subtract space for the title and button
    graphContainer.appendChild(canvas);

    // Get the data to plot
    const selectedData = getDataInRange(data, fromKey, toKey);

    // Prepare data for Chart.js
    const labels = Object.keys(selectedData);
    const values = Object.values(selectedData).map(val => parseFloat(val));

    // Create the chart
    new Chart(canvas.getContext('2d'), {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Data',
                data: values,
                fill: false,
                tension: 0.1
            }]
        },
        options: {
            responsive: false, // Set to false to manage sizing manually
            maintainAspectRatio: false,  // This allows the canvas to resize freely
            plugins: {
                legend: {
                    display: false // This hides the legend
                }
            }
        }
    });

    // Create a close button below the graph
    var closeButton = document.createElement('button');
    closeButton.innerHTML = 'Close';
    closeButton.style.display = 'block';
    closeButton.style.margin = '10px auto 20px'; // Center the button with spacing below
    closeButton.style.padding = '5px 10px';
    closeButton.style.fontSize = '12px';
    closeButton.addEventListener('click', function () {
        popup.removeChild(graphContainer);
        if (popup.children.length === 0) {
            document.body.removeChild(popup);
        }
    });
    graphContainer.appendChild(closeButton);
}





// Function to get data between "From" and "To" keys
function getDataInRange(data, fromKey, toKey) {
    const keys = Object.keys(data);
    const fromIndex = keys.indexOf(fromKey);
    const toIndex = keys.indexOf(toKey);

    if (fromIndex > -1 && toIndex > -1 && fromIndex <= toIndex) {
        return keys.slice(fromIndex, toIndex + 1).reduce((obj, key) => {
            obj[key] = data[key];
            return obj;
        }, {});
    } else {
        console.error('Invalid range selected');
        return {};
    }
}

// Function to populate a dropdown with given options and custom placeholder
function populateDropdown(dropdown, options, placeholder = "Select an option") {
    dropdown.innerHTML = `<option value="">${placeholder}</option>`; // Reset dropdown with custom placeholder
    for (const key in options) {
        if (options.hasOwnProperty(key)) {
            var option = document.createElement('option');
            option.value = key;
            option.textContent = key;
            dropdown.appendChild(option);
        }
    }
}

// Function to fetch and parse JSON data
async function fetchJsonData(filePath) {
    try {
        const response = await fetch(filePath);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching JSON data:', error);
        return null;
    }
}

// Add the dropdownControl to the map
dropdownControl.addTo(map);






        const popup = document.getElementById('popup');
        popup.onmouseover = function () {
            popup.style.display = 'block';
        };
        popup.onmouseout = function () {
            popup.style.display = 'none';
        };

        L.control.layers(baseLayers).addTo(map);
        overlayControl.addTo(map);
        updateFolderDropdown(Object.keys(overlayLayers)[0]);

        // Add a custom button to create a new object
        L.Control.NewObjectControl = L.Control.extend({
            onAdd: function(map) {
                var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
                container.title = 'Add new layer';

                var link = L.DomUtil.create('a', 'leaflet-draw-edit-remove', container);
                link.href = '#';
                link.innerHTML = '<i class="fa-solid fa-square-plus"></i>'; // Using Font Awesome icon

                L.DomEvent.on(container, 'click', function (e) {
                    L.DomEvent.stopPropagation(e);
                    L.DomEvent.preventDefault(e);
                    createNewObject();
                });

                return container;
            }
        });

        function createNewObject() {
            multipartGeoJSON = {
                "type": "FeatureCollection",
                "features": []
            };

            multipartLayer = L.geoJSON(multipartGeoJSON, { style: getGeoJsonStyle() }).addTo(map);

            const layerName = `Draft layer ${Object.keys(activeLayers).length + 1}`;
            // Create a new object with the new layer at the first position
            const newActiveLayers = { [layerName]: multipartLayer, ...activeLayers };
            activeLayers = newActiveLayers;
            currentLayerName = layerName; // Set the current layer name to the new layer
            updateActiveLayersPanel();
        }


        // Add the custom control to the map
        map.addControl(new L.Control.NewObjectControl({ position: 'topleft' }));

        // Add Leaflet Draw controls
        var drawnLayers = [];

        var multipartGeoJSON = {
            "type": "FeatureCollection",
            "features": []
        };

        // Initialize multipartLayer but do not add to map or activeLayers initially
        var multipartLayer = L.geoJSON(multipartGeoJSON, { style: getGeoJsonStyle() });
        var currentLayerName = '';

        // Initialize drawControl with dynamic getGeoJsonStyle function
        var drawControl = new L.Control.Draw({
            draw: {
                polygon: {
                    shapeOptions: getGeoJsonStyle() // Use the selected color dynamically
                },
                polyline: {
                    shapeOptions: {
                        color: selectedColor // Use the selected color
                    }
                },
                rectangle: {
                    shapeOptions: getGeoJsonStyle() // Use the selected color dynamically
                },
                marker: {
                    icon: new L.Icon.Default() // Ensure markers are drawn with the default icon
                },
                circle: false,
                circlemarker: false
            }
        });
        map.addControl(drawControl);


        
        // Handle the creation of drawn items
        map.on(L.Draw.Event.CREATED, function (event) {
            var layer = event.layer;

            // Apply the selected color explicitly to the newly drawn feature
            if (layer.setStyle) {
                layer.setStyle({
                    color: selectedColor,
                    fillColor: lightenColor(selectedColor, 0.5),
                    fillOpacity: 0.5
                });
            }

            // Add the drawn layer to the map and any other necessary collections
            multipartGeoJSON.features.push(layer.toGeoJSON());
            multipartLayer.addData(layer.toGeoJSON());

            // Ensure the active layers panel is up-to-date
            updateActiveLayersPanel();
        });

        // Initialize the drawing control with the selected color
        updateDrawingOptions();

        // Function to update drawing options dynamically based on selected color
        function updateDrawingOptions() {
            drawControl.setDrawingOptions({
                polygon: {
                    shapeOptions: {
                        color: selectedColor, // Use the dynamically updated selected color
                        fillColor: lightenColor(selectedColor, 0.5),
                        fillOpacity: 0.5
                    }
                },
                polyline: {
                    shapeOptions: {
                        color: selectedColor
                    }
                },
                rectangle: {
                    shapeOptions: {
                        color: selectedColor,
                        fillColor: lightenColor(selectedColor, 0.5),
                        fillOpacity: 0.5
                    }
                },
                marker: {
                    icon: new L.Icon.Default() // Markers should retain the default icon
                }
            });
        }

        // Function to update active layers panel
        function updateActiveLayersPanel() {
            const activeLayersList = document.getElementById('activeLayersList');
            activeLayersList.innerHTML = '';
            Object.keys(activeLayers).forEach(layerName => {
                const div = document.createElement('div');

                // Create a checkbox to toggle layer visibility
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = map.hasLayer(activeLayers[layerName]);
                checkbox.onchange = function () {
                    toggleLayer(layerName, this.checked);
                };

                // Create a label for the layer name
                const layerLabel = document.createElement('span');
                layerLabel.textContent = layerName;
                layerLabel.style.cursor = 'pointer';
                layerLabel.onclick = function () {
                    // Mark the selected layer
                    selectedLayer = layerName;
                    // Highlight the selected layer
                    document.querySelectorAll('#activeLayersList span').forEach(span => {
                        span.style.backgroundColor = '';
                    });
                    layerLabel.style.backgroundColor = 'lightblue';
                };
                layerLabel.onmouseover = function (e) {
                    showPopup(e, layerName);
                };
                layerLabel.onmouseout = hidePopup;

                // Add double-click event for renaming the layer
                layerLabel.ondblclick = function () {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = layerName;
                    input.onblur = function () {
                        const newLayerName = input.value.trim();
                        if (newLayerName && newLayerName !== layerName) {
                            activeLayers[newLayerName] = activeLayers[layerName];
                            delete activeLayers[layerName];
                            updateActiveLayersPanel();
                        }
                    };
                    input.onkeydown = function (e) {
                        if (e.key === 'Enter') {
                            input.blur();
                        }
                    };
                    div.replaceChild(input, layerLabel);
                    input.focus();
                };

                // Create a delete button with Font Awesome trash icon
                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = '<i class="fa fa-trash"></i>'; // Using Font Awesome trash icon
                deleteButton.onclick = function () {
                    deleteLayer(layerName);
                };
                deleteButton.style.background = 'none';
                deleteButton.style.border = 'none';
                deleteButton.style.cursor = 'pointer';
                deleteButton.style.color = 'red';

                div.appendChild(checkbox);
                div.appendChild(layerLabel);
                div.appendChild(deleteButton);
                activeLayersList.appendChild(div);
            });
        }


        // Add an event listener to handle clicks outside the active layers list
        document.addEventListener('click', function (event) {
            const activeLayersList = document.getElementById('activeLayersList');
            if (!activeLayersList.contains(event.target) && !event.target.closest('.move-button')) {
                // Clear the selected layer
                selectedLayer = '';

                // Remove the highlight from all layers
                document.querySelectorAll('#activeLayersList span').forEach(span => {
                    span.style.backgroundColor = '';
                });
            }
        });

        // Function to toggle layer visibility
        function toggleLayer(layerName, isChecked) {
            const layer = activeLayers[layerName];
            if (isChecked) {
                layer.addTo(map);
            } else {
                map.removeLayer(layer);
            }

            // Ensure layers are added in the correct order
            updateMapLayerOrder();
        }


        // Function to update the order of layers on the map
        function updateMapLayerOrder() {
            const visibilityStates = {};

            // Store the visibility state of each layer
            Object.keys(activeLayers).forEach(layerName => {
                visibilityStates[layerName] = map.hasLayer(activeLayers[layerName]);
            });

            // Remove all layers
            Object.keys(activeLayers).forEach(layerName => {
                map.removeLayer(activeLayers[layerName]);
            });

            // Re-add layers in the correct order based on visibility state
            Object.keys(activeLayers).reverse().forEach(layerName => {
                if (visibilityStates[layerName]) {
                    activeLayers[layerName].addTo(map);
                }
            });
        }

        // Function to delete a layer
        function deleteLayer(layerName) {
            const layer = activeLayers[layerName];
            if (layer) {
                map.removeLayer(layer);
                delete activeLayers[layerName];
                updateActiveLayersPanel();
            }
        }

        function moveLayerUp() {
            if (selectedLayer) {
                const layerNames = Object.keys(activeLayers);
                const index = layerNames.indexOf(selectedLayer);
                if (index > 0) {
                    // Swap the layers in the activeLayers object
                    const temp = layerNames[index - 1];
                    layerNames[index - 1] = layerNames[index];
                    layerNames[index] = temp;

                    // Recreate the activeLayers object with the new order
                    const newActiveLayers = {};
                    const visibilityStates = {};

                    layerNames.forEach(layerName => {
                        newActiveLayers[layerName] = activeLayers[layerName];
                        visibilityStates[layerName] = map.hasLayer(activeLayers[layerName]);
                    });

                    // Update the activeLayers reference
                    Object.keys(activeLayers).forEach(key => delete activeLayers[key]);
                    Object.assign(activeLayers, newActiveLayers);

                    // Re-add layers to the map in the new order
                    Object.keys(activeLayers).forEach(layerName => {
                        map.removeLayer(activeLayers[layerName]);
                    });

                    // Re-add layers to the map in the new order and reapply visibility
                    Object.keys(activeLayers).reverse().forEach(layerName => {
                        map.removeLayer(activeLayers[layerName]);
                        if (visibilityStates[layerName]) {
                            activeLayers[layerName].addTo(map);
                        }
                    });

                    updateActiveLayersPanel();

                    // Reapply highlight to the selected layer
                    document.querySelectorAll('#activeLayersList span').forEach(span => {
                        if (span.textContent === selectedLayer) {
                            span.style.backgroundColor = 'lightblue';
                        }
                    });
                }
            }
        }

        function moveLayerDown() {
            if (selectedLayer) {
                const layerNames = Object.keys(activeLayers);
                const index = layerNames.indexOf(selectedLayer);
                if (index < layerNames.length - 1) {
                    // Swap the layers in the activeLayers object
                    const temp = layerNames[index + 1];
                    layerNames[index + 1] = layerNames[index];
                    layerNames[index] = temp;

                    // Recreate the activeLayers object with the new order
                    const newActiveLayers = {};
                    const visibilityStates = {};

                    layerNames.forEach(layerName => {
                        newActiveLayers[layerName] = activeLayers[layerName];
                        visibilityStates[layerName] = map.hasLayer(activeLayers[layerName]);
                    });
                    
                    // Update the activeLayers reference
                    Object.keys(activeLayers).forEach(key => delete activeLayers[key]);
                    Object.assign(activeLayers, newActiveLayers);

                    // Re-add layers to the map in the new order
                    Object.keys(activeLayers).forEach(layerName => {
                        map.removeLayer(activeLayers[layerName]);
                    });

                    // Re-add layers to the map in the new order and reapply visibility
                    Object.keys(activeLayers).reverse().forEach(layerName => {
                        map.removeLayer(activeLayers[layerName]);
                        if (visibilityStates[layerName]) {
                            activeLayers[layerName].addTo(map);
                        }
                    });

                    updateActiveLayersPanel();

                    // Reapply highlight to the selected layer
                    document.querySelectorAll('#activeLayersList span').forEach(span => {
                        if (span.textContent === selectedLayer) {
                            span.style.backgroundColor = 'lightblue';
                        }
                    });
                }
            }
        }
    </script>
</body>
</html>
